<!DOCTYPE html><html lang="en" data-astro-cid-sckkx6r4> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v5.3.0"><title>GopherHack</title><link rel="stylesheet" href="/_astro/poster.B_Cpo-Oc.css">
<link rel="stylesheet" href="/_astro/_name_.B51i_3Fs.css">
<link rel="stylesheet" href="/_astro/_post_.aVDCQf0I.css"></head> <body data-astro-cid-sckkx6r4> <section class="mainSection" data-astro-cid-sckkx6r4> <div class="content" data-astro-cid-sckkx6r4> <header data-astro-cid-sckkx6r4> <div data-astro-cid-sckkx6r4> <!-- left --> <a href="/" id="logo" data-astro-cid-sckkx6r4>
&#x1F6A9; GopherHack</a> </div> <div data-astro-cid-sckkx6r4> <!-- right --> <div class="links" data-astro-cid-sckkx6r4> <a href="/pages/contests" data-astro-cid-sckkx6r4>Contests</a> <a href="/pages/blog" data-astro-cid-sckkx6r4>Blog</a> <a href="/pages/resources" data-astro-cid-sckkx6r4>Resources</a> <a href="/pages/officers" data-astro-cid-sckkx6r4>Officers</a> </div> <div class="buttons" data-astro-cid-sckkx6r4></div> </div> </header> <main data-astro-cid-sckkx6r4>  <h1 data-astro-cid-quoef3qp>  TUCTF 2025: Simpler Cipher </h1> <div class="metadata" data-astro-cid-quoef3qp> <div title="2025-01-27T06:35:25.235Z" data-astro-cid-quoef3qp> Monday, January 27, 2025 </div> <div data-astro-cid-quoef3qp>
Authored by <a href="/authors/michael">michael</a> </div> <div data-astro-cid-quoef3qp>
CTF:  <a href="/pages/contests#ctftime-2584" data-astro-cid-quoef3qp> TUCTF 2024 </a> </div> <div data-astro-cid-quoef3qp>Tags: crypto</div> </div> <div class="postContent" data-astro-cid-quoef3qp> <p>For the challenge, we are given <a href="/_astro/cipher.QZ-bymXo.py">this file</a>.
Unlike typical crypto server challenges, this code does an unusual conversion to binary form.</p>
<p>The encryption algorithm requires 2 pieces we don’t know:</p>
<ol>
<li>a secret key, which is 6 bytes long</li>
<li>the conversion tables, <code>exptables</code>, found at the top of the file</li>
</ol>
<p>The algorithm “encrypts” the flag by first running a conversion step by taking
every 4 bits and converting it to 6 bits through a lookup table. Then, it XORs
this result against the key in 6-byte chunks. Since the lookup table is unique,
decryption is the reverse process; first it XORs the given ciphertext, then
reverses the lookup.</p>
<p>Here is the conversion process, called “expand”:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="py"><code><span class="line"><span style="color:#F97583">def</span><span style="color:#B392F0"> expand</span><span style="color:#E1E4E8">(ctext):</span></span>
<span class="line"><span style="color:#E1E4E8">    ct</span><span style="color:#F97583">=</span><span style="color:#9ECBFF">&#39;&#39;</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> range</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">,</span><span style="color:#79B8FF">len</span><span style="color:#E1E4E8">(ctext),</span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">):</span></span>
<span class="line"><span style="color:#E1E4E8">        msb </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ctext[i:i</span><span style="color:#F97583">+</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">        lsb </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ctext[i</span><span style="color:#F97583">+</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">:i</span><span style="color:#F97583">+</span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">]</span></span>
<span class="line"><span style="color:#E1E4E8">        exp </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> exptables[</span><span style="color:#79B8FF">int</span><span style="color:#E1E4E8">(msb,</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">)][</span><span style="color:#79B8FF">int</span><span style="color:#E1E4E8">(lsb,</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">)]</span></span>
<span class="line"><span style="color:#E1E4E8">        ct</span><span style="color:#F97583">+=</span><span style="color:#E1E4E8">exp</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> ct</span></span></code></pre>
<p><code>ctext</code> here is a string of either <code>&quot;1&quot;</code> or <code>&quot;0&quot;</code>. As we can see, the 4 bits are
broken down into two pieces of 2 bits each, which are treated as indices in a
two-level lookup table.</p>
<p>Since the challenge server provides us with an encryption oracle, we can brute
force the unknown tables by using a predictable key. For example, the plaintext
<code>&quot;AAAAAA&quot;</code> and the key <code>&quot;AAAAAA&quot;</code> should cancel out, leaving us with all zeroes
entering the conversion step. This reveals to us what the combination (0, 0)
maps to in the lookup table.</p>
<p>Using this logic, we can write a function to create a string that enumerates all
the possible lookup keys. I chose to vary the keys rather than the string. This means I had to ask the encryption oracle for the corresponding ciphertexts of two strings:</p>
<ul>
<li><code>40620426c8ea</code></li>
<li><code>8cae41414141</code></li>
</ul>
<p>The 41414141 at the end is there because there’s only 64 bits of combinations,
so I padded it to be a multiple of 48 bits (the key size).</p>
<p>After asking the server for the ciphertexts, I got:</p>
<ul>
<li><code>010101011001101101110011010001000101100001111000101000011110011101101110</code></li>
<li><code>111100110001010010101010010101010101010101010101010101010101010101010101</code></li>
</ul>
<p>Now I can break these into 6-bit chunks and build the lookup tables.</p>
<p>Finally, I know the flag format begins with <code>TUCTF{</code>. So I simply brute-forced
each character of the key until I found it (honestly this could probably have
been done in a more direct way but this way was faster).</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="py"><code><span class="line"><span style="color:#E1E4E8">flagkey </span><span style="color:#F97583">=</span><span style="color:#F97583"> b</span><span style="color:#9ECBFF">&quot;AAAAAA&quot;</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> i, c </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> enumerate</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">b</span><span style="color:#9ECBFF">&quot;TUCTF{&quot;</span><span style="color:#E1E4E8">):</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> range</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">256</span><span style="color:#E1E4E8">):</span></span>
<span class="line"><span style="color:#E1E4E8">        newflagkey </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> list</span><span style="color:#E1E4E8">(flagkey)</span></span>
<span class="line"><span style="color:#E1E4E8">        newflagkey[i] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> j</span></span>
<span class="line"><span style="color:#E1E4E8">        newflagkey </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> bytes</span><span style="color:#E1E4E8">(newflagkey)</span></span>
<span class="line"><span style="color:#E1E4E8">        flagptxt </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> decode(flagctxt, newflagkey)</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> flagptxt[i] </span><span style="color:#F97583">==</span><span style="color:#E1E4E8"> c:</span></span>
<span class="line"><span style="color:#E1E4E8">            flagkey </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> newflagkey</span></span>
<span class="line"><span style="color:#F97583">            break</span></span>
<span class="line"><span style="color:#79B8FF">    print</span><span style="color:#E1E4E8">(c)</span></span></code></pre>
<p>Using this key with the flag that the server gives us reveals the final flag, <code>TUCTF{tr@ck_th3_exp@nsi0ns_and_r3v3rs3}</code>.</p>
<p>My final solve script can be found <a href="/_astro/solve.Ds15GyWX.py">here</a>.</p> </div>  </main> <footer data-astro-cid-sckkx6r4>
&mdash;
<a href="https://github.com/gopherhackumn/website" target="_blank" rel="noopener" data-astro-cid-sckkx6r4>Website source</a>
&mdash;
</footer> </div> </section> </body></html> 