<!DOCTYPE html><html lang="en" data-astro-cid-sckkx6r4> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v5.5.5"><title>GopherHack</title><link rel="stylesheet" href="/_astro/poster.B_Cpo-Oc.css">
<link rel="stylesheet" href="/_astro/_name_.B51i_3Fs.css">
<link rel="stylesheet" href="/_astro/_post_.aVDCQf0I.css"></head> <body data-astro-cid-sckkx6r4> <section class="mainSection" data-astro-cid-sckkx6r4> <div class="content" data-astro-cid-sckkx6r4> <header data-astro-cid-sckkx6r4> <div data-astro-cid-sckkx6r4> <!-- left --> <a href="/" id="logo" data-astro-cid-sckkx6r4>
&#x1F6A9; GopherHack</a> </div> <div data-astro-cid-sckkx6r4> <!-- right --> <div class="links" data-astro-cid-sckkx6r4> <a href="/pages/contests" data-astro-cid-sckkx6r4>Contests</a> <a href="/pages/blog" data-astro-cid-sckkx6r4>Blog</a> <a href="/pages/resources" data-astro-cid-sckkx6r4>Resources</a> <a href="/pages/officers" data-astro-cid-sckkx6r4>Officers</a> </div> <div class="buttons" data-astro-cid-sckkx6r4></div> </div> </header> <main data-astro-cid-sckkx6r4>  <h1 data-astro-cid-quoef3qp>  BITSCTF 2025: RSA Bummer </h1> <div class="metadata" data-astro-cid-quoef3qp> <div title="2025-02-14T08:57:16.633Z" data-astro-cid-quoef3qp> Friday, February 14, 2025 </div> <div data-astro-cid-quoef3qp>
Authored by <a href="/authors/dajeff">dajeff</a> </div> <div data-astro-cid-quoef3qp>
CTF:  <a href="/pages/contests#ctftime-2607" data-astro-cid-quoef3qp> BITSCTF 2025 </a> </div> <div data-astro-cid-quoef3qp>Tags: crypto</div> </div> <div class="postContent" data-astro-cid-quoef3qp> <link rel="stylesheet" href="/_astro/styles.DOL_VcOL.css"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css" integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossOrigin="anonymous"/>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js" integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossOrigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossOrigin="anonymous" onLoad="renderMathInElement(document.body);"></script>
<h3 id="problem-summary">Problem Summary</h3>
<blockquote>
<p>RSA was bad as it was, but now it has gone to dogs!</p>
<p>Wrap the flag inside BITSCTF{..}.</p>
<p><code>nc chals.bitskrieg.in 7001</code></p>
<blockquote>
<p>Metapod_04</p>
</blockquote>
<a href="/_astro/chall.CGmnZJL2.py">chall.py</a>
</blockquote>
<p><a href="/_astro/chall.CGmnZJL2.py">chall.py</a> starts by defining a function <code>lmao</code> (shown later in this writeup) and variables <code>e, p, q, r, modulo, pseudo_n, multiplier, flag</code>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="py"><code><span class="line"><span style="color:#E1E4E8">e </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 27525540</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">while</span><span style="color:#79B8FF"> True</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#E1E4E8">    p </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> getPrime(</span><span style="color:#79B8FF">1024</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (((</span><span style="color:#79B8FF">15</span><span style="color:#F97583">-</span><span style="color:#E1E4E8">GCD(e,(p</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">)))</span><span style="color:#F97583">&gt;&gt;</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">31</span><span style="color:#E1E4E8">))</span><span style="color:#F97583">==</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">):</span></span>
<span class="line"><span style="color:#F97583">        break</span></span>
<span class="line"><span style="color:#E1E4E8">q </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> getPrime(</span><span style="color:#79B8FF">1024</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">r </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> getPrime(</span><span style="color:#79B8FF">1024</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">modulo </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> p</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">r</span></span>
<span class="line"><span style="color:#E1E4E8">pseudo_n </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> r</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">pow</span><span style="color:#E1E4E8">(e,p,q))</span></span>
<span class="line"><span style="color:#E1E4E8">multiplier </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> getPrime(</span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">flag </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> bytes</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">FLAG</span><span style="color:#E1E4E8">)</span></span></code></pre>
<p>Notably, \(e = 2^2\cdot 3\cdot 5\cdot 7\cdot 65537\) and <code>multiplier</code> is a 4-bit prime, which is small.</p>
<p>We are given <code>pseudo_n, e</code> as well as a version of the flag, which is broken into three parts and encrypted with RSA.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="py"><code><span class="line"><span style="color:#79B8FF">print</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;Pseudo_n = &quot;</span><span style="color:#E1E4E8">, pseudo_n)</span></span>
<span class="line"><span style="color:#79B8FF">print</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;e = &quot;</span><span style="color:#E1E4E8">, e)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> range</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">):</span></span>
<span class="line"><span style="color:#E1E4E8">    pt </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> flag [ i</span><span style="color:#F97583">*</span><span style="color:#79B8FF">len</span><span style="color:#E1E4E8">(flag)</span><span style="color:#F97583">//</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8"> : (i</span><span style="color:#F97583">+</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">*</span><span style="color:#79B8FF">len</span><span style="color:#E1E4E8">(flag)</span><span style="color:#F97583">//</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8"> ]</span></span>
<span class="line"><span style="color:#E1E4E8">    ct </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> pow</span><span style="color:#E1E4E8">(bytes_to_long(pt),e,(p</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">q))</span></span>
<span class="line"><span style="color:#79B8FF">    print</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">f</span><span style="color:#9ECBFF">&quot;Ciphertext </span><span style="color:#79B8FF">{</span><span style="color:#E1E4E8">i</span><span style="color:#F97583">+</span><span style="color:#79B8FF">1}</span><span style="color:#9ECBFF"> =&quot;</span><span style="color:#E1E4E8">, ct)</span></span></code></pre>
<p>We have five chances to enter an integer <code>x</code> such that <code>3 &lt;= x &lt;= 23</code>. The server then outputs a result equivalent to that of <code>lmao(modulo,multiplier,x)</code>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="py"><code><span class="line"><span style="color:#F97583">def</span><span style="color:#B392F0"> lmao</span><span style="color:#E1E4E8">(n,k,x):  </span><span style="color:#6A737D">#Better function needed</span></span>
<span class="line"><span style="color:#E1E4E8">    pseudo_p </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8"> </span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> range</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">,k</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">n</span><span style="color:#F97583">-</span><span style="color:#E1E4E8">x):</span></span>
<span class="line"><span style="color:#F97583">        try</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#E1E4E8"> (GCD(i,n</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">^</span><span style="color:#E1E4E8">(n</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">!=</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">):</span></span>
<span class="line"><span style="color:#E1E4E8">                pseudo_p </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (pseudo_p</span><span style="color:#F97583">*</span><span style="color:#E1E4E8">inverse(i,n))</span><span style="color:#F97583">%</span><span style="color:#E1E4E8">n</span></span>
<span class="line"><span style="color:#F97583">        except</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#F97583">            continue</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> inverse(pseudo_p,n)</span></span></code></pre>
<p>Our goal is to recover the flag from the ciphertexts.</p>
<h3 id="solution">Solution</h3>
<p><code>lmao</code> looks a bit strange, so let’s clean it up a bit.</p>
<ul>
<li>The condition <code>GCD(i,n-1)^(n-1)!=0</code> is equivalent to <code>GCD(i, n - 1) != n - 1</code> (due to properties of XOR), which is in turn equivalent to <code>i % (n - 1) != 0</code> (since \(\gcd(i, n - 1) = n - 1\) iff \(n - 1\mid i\)).</li>
<li>Moreover, an exception will only be thrown from <code>inverse(i, n)</code>, under the condition that <code>i</code> does not have an inverse modulo <code>n</code>, i.e. \(\gcd(i, n) \neq 1\). Thus, we only take the product for <code>i</code> such that \(\gcd(i, n) = 1\).</li>
<li>Finally, after we compute <code>pseudo_p</code>, which is a product of inverses \(i^{-1}\bmod n\), we take the inverse of the whole product again, meaning <code>pseudo_p</code> is effectively just a product of \(i\bmod n\) (since the inverses cancel out).</li>
</ul>
<p>Cleaning up, <code>lmao</code> produces the same output as</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="py"><code><span class="line"><span style="color:#F97583">def</span><span style="color:#B392F0"> lmao</span><span style="color:#E1E4E8">(n, k, x):</span></span>
<span class="line"><span style="color:#E1E4E8">    pseudo_p </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> range</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, k </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> n </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> x):</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">%</span><span style="color:#E1E4E8"> (n </span><span style="color:#F97583">-</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">!=</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583"> and</span><span style="color:#E1E4E8"> GCD(i, n) </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#E1E4E8">            pseudo_p </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (pseudo_p </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> i) </span><span style="color:#F97583">%</span><span style="color:#E1E4E8"> n</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> pseudo_p</span></span></code></pre>
<p>We may notice something special might happen when <code>x</code> is around <code>k</code>, as the condition <code>i % (n - 1) != 0</code> is false when <code>i == k * n - k</code>. Let’s formalize it.</p>
<p>In mathematical notation, we’ll write
\[\operatorname{lmao}(n, k, x) := \left(\prod_{\substack{i=2,\\n-1\nmid i,\\\gcd(i,n)=1}}^{kn-x-1} i\right) \bmod n\]
in reference to how <code>lmao</code> does this product.</p>
<p>Observe that
\[\begin{align*}
\operatorname{lmao}(n, k, k - 1) &amp;= \left(\prod_{\substack{i=2,\\n-1\nmid i,\\\gcd(i,n)=1}}^{kn-k} i\right) \bmod n
\\ &amp;= \left(\prod_{\substack{i=2,\\n-1\nmid i,\\\gcd(i,n)=1}}^{kn-k-1} i\right) \bmod n
\\ &amp;= \operatorname{lmao}(n, k, k)
\end{align*}\]
since \(n - 1\mid kn - k\), meaning it is not included in the product. Also recall that the server returns the value of <code>lmao(modulo,multiplier,x)</code> (we’ll use \(n = \mathrm{modulo}, k = \mathrm{multiplier}\) from here on out). Since \(k\) is a 4-bit prime (i.e. it is either \(11\) or \(13\)), <strong>we can determine the value of \(k\)</strong> by sending \(x = 10, 11, 12, 13\). If the return values for \(x = 10, 11\) are the same, then \(k = 11\) by the above equation; otherwise \(k = 13\).</p>
<p>Now that we know the value of \(k\), let’s do some more analysis on \(\operatorname{lmao}(n, k, k - 1)\). The set of \(i\) such that \(\gcd(i, n) = 1\) (i.e. the multiplicative inverse of \(i\) exists) is called the set of units and is well studied. We may notice that there is a sort of cyclic nature in the product (e.g. the product is essentially a product of \(k\) sets of units, minus a few elements), so we’ll focus on the product of these units.</p>
<p>As it turns out, the product of units modulo a semiprime \(n\) is \(1\).</p>
<details><summary>Why is the product of units modulo a semiprime \(1\)?</summary><p><a href="https://en.wikipedia.org/wiki/Wilson%27s_theorem">Wilson’s Theorem</a> states that for all primes \(p\), we have that the product of all units \((p - 1)!\) satisfies \((p - 1)!\equiv -1\pmod p\). The proof is that all units come in multiplicative inverse pairs that will cancel out in the product except for the units \(u\) that are their own mulitplicative inverse, i.e.
\[\begin{align*}
u&amp;\equiv u^{-1}\pmod p
\\ u^2&amp;\equiv 1\pmod p
\\ u^2 - 1&amp;\equiv 0\pmod p
\\ u&amp;\equiv -1, 1\pmod p,
\end{align*}\]
where the last step comes from a famous result in field theory that states that a nonzero polynomial of degree \(d\) modulo a prime \(p\) as at most \(d\) roots. Thus, the product of all units is \(-1\cdot 1 = -1\).</p><p>The product of units for semiprime \(n = pr\) is slightly different, as we cannot directly apply the previously mentioned result from field theory. Instead, all units come in multiplicative inverse pairs except for the units \(u\) that satisfy
\[\begin{align*}
u&amp;\equiv u^{-1}\pmod n
\\ u^2 - 1&amp;\equiv 0\pmod n
\end{align*}\]
\[\begin{align*}
u^2 - 1&amp;\equiv 0\pmod p &amp; u^2 - 1&amp;\equiv 0\pmod r
\\ u&amp;\equiv -1, 1\pmod p &amp; u&amp;\equiv -1, 1\pmod r
\end{align*}\]
by the Chinese Remainder Theorem. Thus, there are \(2\cdot 2 = 4\) units whose inverse is themselves, namely \(u_1, u_2, u_3, u_4\) that satisfy
\[\begin{align*}
u_0&amp;\equiv -1\pmod p &amp; u_0&amp;\equiv -1\pmod r
\\ u_1&amp;\equiv -1\pmod p &amp; u_1&amp;\equiv 1\pmod r
\\ u_2&amp;\equiv 1\pmod p &amp; u_2&amp;\equiv -1\pmod r
\\ u_3&amp;\equiv 1\pmod p &amp; u_3&amp;\equiv 1\pmod r.
\end{align*}\]
The product of these units is
\[(-1)(-1)\cdot 1\cdot 1 \equiv 1\pmod p\]
and
\[(-1)\cdot 1\cdot(-1)\cdot 1 \equiv 1\pmod r,\]
so by the Chinese Remainder Theorem, the product is \(1\) modulo \(n\).</p></details>
<p>Continuing with our analysis of <code>lmao</code> to account for this, let’s first get rid of some conditions by separating \(i\) such that \(n - 1\mid i\) out of the product.
\[\begin{align*}
\prod_{\substack{i=2,\\n-1\nmid i,\\\gcd(i,n)=1}}^{kn-k} i &amp;\equiv \left(\prod_{\substack{i=2,\\\gcd(i,n)=1}}^{kn-k} i\right)\left(\prod_{\substack{i=2,\\n - 1\mid i}}^{kn-k} i\right)^{-1} \pmod n
\\ &amp;\equiv \left(\prod_{\substack{i=2,\\\gcd(i,n)=1}}^{kn-k} i\right)((n - 1)(2n - 2)\cdots (kn - k))^{-1} \pmod n
\\ &amp;\equiv \left(\prod_{\substack{i=2,\\\gcd(i,n)=1}}^{kn-k} i\right)((-1)^k\cdot k!)^{-1} \pmod n
\end{align*}\]
Focusing on the first term, let’s again simplify the problem by making the product range from \(i = 2\) to \(kn\) (instead of \(kn - k\)).
\[\begin{align*}
\\ \prod_{\substack{i=2,\\\gcd(i,n)=1}}^{kn-k} i &amp;\equiv \left(\prod_{\substack{i=2,\\\gcd(i,n)=1}}^{kn} i\right)\left(\prod_{\substack{i=kn-k+1,\\\gcd(i,n)=1}}^{kn} i\right)^{-1} \pmod n
\\ &amp;\equiv \left(\prod_{\substack{i=2,\\\gcd(i,n)=1}}^{kn} i\right)((kn - 1)(kn - 2)\cdots (kn - k + 1))^{-1} \pmod n
\\ &amp;\equiv \left(\prod_{\substack{i=2,\\\gcd(i,n)=1}}^{kn} i\right)((-1)^{k-1}(k - 1)!)^{-1} \pmod n
\end{align*}\]
Finally, the product of units is \(1\), so
\[\prod_{\substack{i=2,\\\gcd(i,n)=1}}^{kn} i \equiv 1\pmod n.\]
Combining this all together, we have
\[\begin{align*}
\operatorname{lmao}(n, k, k - 1) &amp;\equiv \left(\prod_{\substack{i=2,\\\gcd(i,n)=1}}^{kn-k} i\right)\left(\prod_{\substack{i=kn-k+1,\\\gcd(i,n)=1}}^{kn} i\right)^{-1}\left(\prod_{\substack{i=2,\\n - 1\mid i}}^{kn-k} i\right)^{-1}\pmod n
\\ &amp;\equiv 1\cdot ((-1)^{k-1}(k - 1)!)^{-1}\cdot ((-1)^k\cdot k!)^{-1}\pmod n
\\ &amp;\equiv (-(k - 1)!k!)^{-1} \pmod n.
\end{align*}\]</p>
<p>This means that
\[\begin{align*}
\operatorname{lmao}(n, k, k - 1)(k - 1)!k! &amp;\equiv -1\pmod n.
\\ \mathrm{large} := \operatorname{lmao}(n, k, k - 1)(k - 1)!k! + 1 &amp;\equiv 0\pmod n.
\end{align*}\]
so we can find a prime factor \(r\) of \(n\) by taking \(\gcd(\mathrm{large}, \mathrm{pseudo\_n})\).</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="python"><code><span class="line"><span style="color:#E1E4E8">lucky </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 5013846788728970106981286568035850741510050958651719688793565241746763951237597385789456422355290131911960893124306704535430840764505962087579852251387223473408382775532681027486642795845613056526111047319999052391171988132594264091105556738766092622128123234218481277217365462624251865908413965413703317915494455334209190162571673453780337597871238287728383297279201323086922663893401420724242318735169522781251476879432026866527168584211903251695041263496038018323762440787331977006619381253641478882038701393969473301303678923181843766561832650727043140511451419703017904887191617608727752859093957833065767210051</span></span>
<span class="line"><span style="color:#6A737D"># ...</span></span>
<span class="line"><span style="color:#E1E4E8">large </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> lucky </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> factorial(k </span><span style="color:#F97583">-</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> factorial(k) </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span></span>
<span class="line"><span style="color:#E1E4E8">r </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> gcd(large, pseudo_n)</span></span></code></pre>
<p>To find the other prime factor \(p\) of \(n = pr\), we can note that \(\mathrm{large} = \operatorname{lmao}(n, k, k - 1)(k - 1)!k!\) is at most around \((k - 1)!k!\cdot n\). Hence all prime factors of \(\mathrm{large}\) other than \(p, r\) are small, meaning prime factoring \(\mathrm{large} / r\) and taking the largest prime factor yields \(p\).</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="python"><code><span class="line"><span style="color:#79B8FF">print</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;large / r:&quot;</span><span style="color:#E1E4E8">, factor(large </span><span style="color:#F97583">/</span><span style="color:#E1E4E8"> r))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">p </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 97024739464998702506669770040122555405744744329112361431296849602425176888706677027168942602346601410275677551642583542221372889929921169129152046628767518204950634335610816971646728944584206197909423063817745571547831875610836246031230531848786470473211134081105553332730836486257401821895577462008987410887</span></span></code></pre>
<p>We have a factor of the modulus used for the RSA encryption, so we can decrypt the flag now (by looking at the flag modulo \(p\)). A potential problem may be that \(e, p - 1\) are not relatively prime, but we can resolve this in a similar way to the <a href="https://en.wikipedia.org/wiki/Rabin_cryptosystem">Rabin cryptosystem</a>.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8;overflow-x:auto" tabindex="0" data-language="python"><code><span class="line"><span style="color:#79B8FF">print</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">&quot;GCD:&quot;</span><span style="color:#E1E4E8">, gcd(e, p </span><span style="color:#F97583">-</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">))  </span><span style="color:#6A737D"># 2</span></span>
<span class="line"><span style="color:#E1E4E8">d </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> pow</span><span style="color:#E1E4E8">(e </span><span style="color:#F97583">//</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, p </span><span style="color:#F97583">-</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF">print</span><span style="color:#E1E4E8">(binascii.unhexlify(</span><span style="color:#79B8FF">hex</span><span style="color:#E1E4E8">(isqrt(</span><span style="color:#79B8FF">pow</span><span style="color:#E1E4E8">(c1, d </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> (p </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">//</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">, p)))[</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">:]) </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> binascii.unhexlify(</span><span style="color:#79B8FF">hex</span><span style="color:#E1E4E8">(isqrt(</span><span style="color:#79B8FF">pow</span><span style="color:#E1E4E8">(c2, d </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> (p </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">//</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">, p)))[</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">:]) </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> binascii.unhexlify(</span><span style="color:#79B8FF">hex</span><span style="color:#E1E4E8">(isqrt(</span><span style="color:#79B8FF">pow</span><span style="color:#E1E4E8">(c3, d </span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> (p </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">//</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">, p)))[</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">:]))</span></span></code></pre>
<details><summary>Why does this code work?</summary><p>Assume that \(\gcd(e/4, p - 1) = 1\); see the comment after this section if not. Let \(\mathrm{pt}, \mathrm{ct}\) be the plaintext and ciphertext respectively. Let \(\mathrm{d} := (e/4)^{-1}\bmod{p - 1}\). Then,
\[\begin{align*}
\mathrm{pt}^e &amp;\equiv \mathrm{ct}\pmod{p - 1}
\\ \mathrm{pt}^{e/4\cdot 4} &amp;\equiv \mathrm{ct}\pmod{p - 1}
\\ \mathrm{pt}^{(e/4\cdot d)\cdot 4} &amp;\equiv \mathrm{ct}^d\pmod{p - 1}
\\ \mathrm{pt}^4 &amp;\equiv \mathrm{ct}^d\pmod{p - 1}.
\end{align*}\]
If \(\mathrm{pt}\) is small enough we can compute \(\sqrt[4]{\mathrm{ct}^d\bmod{p - 1}}\) to retrieve the flag. In fact, this is an alternative approach; try it! What happens if you replace <code>isqrt(pow(c1, d * (p + 1) // 4, p))</code> with <code>isqrt(isqrt(pow(c1, d, p)))</code> in the above code/in the solve script?</p><p>If \(\mathrm{pt}\) is not small enough and \(p\equiv 3\pmod 4\), we can note
\[\begin{align*}
\mathrm{pt}^4 &amp;\equiv \mathrm{ct}^d\pmod{p - 1}
\\ \mathrm{pt}^{4\cdot (p + 1)/4} &amp;\equiv \mathrm{ct}^{d(p + 1)/4}\pmod{p - 1}
\\ \mathrm{pt}^{p + 1} &amp;\equiv \mathrm{ct}^{d(p + 1)/4}\pmod{p - 1}
\\ \mathrm{pt}^2 &amp;\equiv \mathrm{ct}^{d(p + 1)/4}\pmod{p - 1}
\end{align*}\]
and compute a potential plaintext \(\sqrt{\mathrm{ct}^{d(p + 1)/4}\bmod{p - 1}}\).</p></details>
<p>If the GCD is not a power of \(2\) (e.g. the GCD contains a factor of \(5\)), we can instead compute something like \(d = (e/20)^{-1}\bmod{p - 1}\) and take the tenth root of the result instead of the square root.</p>
<p>Flag: <code>BITSCTF{s0_fun_7o_50lv3_5ef78a03}</code></p>
<p>The final solve script can be found <a href="/_astro/solve.DTQOTR4T.sage">here</a>.</p> </div>  </main> <footer data-astro-cid-sckkx6r4>
&mdash;
<a href="https://github.com/gopherhackumn/website" target="_blank" rel="noopener" data-astro-cid-sckkx6r4>Website source</a>
&mdash;
</footer> </div> </section> </body></html> 